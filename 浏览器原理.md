### 浏览器原理

- UDP -- （User Datagram Protocol）（用户协议包）目的把 ip 协议传输的数据包运送到对应的应用，比如给浏览器，还是给某应用。IP 通过 ip 地址信息发送数据包，UDP 通过端口好找到对应 的应用。

  - 缺点：容易丢包（因为一旦失去链接，没有提供重连机制），大文件会被拆分成若干肖的数据包来传输，UDP 不知道如何去组合这些拆分的数据包，无法还原成源文件。

- TCP （Transmission Control Protocol, 传输控制协议）是一种面向连接的，可靠的，基于字节流的传输层通信协议。

  解决了 UDP 的丢包问题

  - 对于数据包丢失的情况，提供重连机制
  - 引入了数据包排序机制，用来保证把乱序的数据包组合成一个完整的文件。

```
现在的浏览器可以同时打开多个页签，他们端口一样吗？如果一样，数据怎么知道去哪个页签？
回复: 端口一样的，网络进程知道每个tcp链接所对应的标签是那个，所以接收到数据后，会把数据分发给对应的渲染进程

```

**TCP 连接过程**，包括“**建立链接**” “**传输数据**” “**断开连接**” 三个阶段，这就是如何保证重连机制和数据包排序功能，俗称‘三次握手，四次挥手’。


域名和ip有一个映射关系，组成一个域名系统，简称DNS（Domain Name System）

http连接第一步，域名解析（DNS 解析）这里也会涉及DNS数据缓存


tcp连接，**三次握手**  **四次挥手**

`三次握手目的是为了防止已失效链接（connect）请求报文段传送到了服务端，因为产生错误，也是为了解决网络中存在延迟重复的分组问题。例如：client发出的第一个连接请求报文段并没有丢失，而是在某个网络节点长时间直流了，导致延误连接释放后的某个时间才到达服务端。本来这是一个早已失效的报文，但服务端收到已失效的连接请求报文段后，就误认为是客户端发出的新的请求连接。于是就像客户端发出确认报文段，同意创建连接，假设不采用三次握手，那么只要服务端确认，新的连接就创建了。由于现在的客户端并没有发出创建连接的请求。因此不会理财服务端的确认，也不会向服务端发送数据，但是服务端却认为新的连接已经创建，并一直等待客户端发来的数据。这样，服务端的很多资源就会浪费。采用三次握手的办法可以防止上述的情况发生，客户端不会向服务端的确认发出确认。服务端收不到确认就知道客户端并没有要求创建连接。`


三次握手过程：

    1. 客户端（通过执行connect函数）向服务端发送一个SYN包，请求主动打开一个通道，该包为这个请求携带一个随机数作为消息序列号，这里称作 **A**
    2. 服务端收到一个合法的SYN后，把该包放入SYN对列中，会送一个SYN/ACK。ACK确认码为**A+1**,SYN/SCK包本身携带一个随机产生的序列号**B**
    3. 客户端收到SYN/ACK后，发送一个ACK包，该包的序列号设定为**A+1**, 而ACK的确认码则为**B+1**.然后客户端的connect函数成功返回。当服务端收到这个ACK包的时候，把请求帧从SYN队列中移出，放入ACCEPT队列；这是accept函数如果处于阻塞状态，可以被唤醒，从Accept队列中取出ACK包，重新创建一个新的勇于双向通行的sockfd，并返回。

    以上就是一次完整的三次握手过程，但是也不乏一些连接丢失的情况。如果服务端收到了客户端发的SYN后，回了SYN-ACK后客户端掉线了，服务端没有收到客户端回来的ACK，那么这个连接处于一个中间状态，既没有成功，也有没有失败。于是服务器端如果在一定时间内没有收到的TCP会重发SYN-ACK。在Linux下，默认会重试5次，重试的间隔时间从1s开始每次翻倍，5次的重试时间间隔为1s，2s，4s，8s，16s,总共31s，第5次发出后还要等32s才知道第5次也超时了，所以总共需要`1s+2s+4s+8s+16s+32s = 63s`，TCP才会断开连接。使用三个TCP参数来调整行为，分别是tcp_synack_retries减少重试次数，tcp_max_syn_backlog,增大SYN连接数；tck_abort_on_overflow决定超出能力时的行为。


四次挥手也就是断开连接过程：


        首先发出FIN的一侧，如果给对策的FIN响应了ACK，那么就会超时等待2*MSL时间，然后关闭连接。在这段超时等待时间内，本地端口不能被新的连接使用；避免延时的包到达随后的新连接混合。RFC739定义了MSL为2分钟，Linux设置成了30s。参数tcp_max_tw_buckets控制并发的TIME_WAIT的数量，默认值是180000，如果超限那么，系统会把多的TIME_WAIT状态的连接给destroy掉，然后再日志里打一个警告（如：time await bucket table overflow）连接可以工作再TCP半开状态。即一侧关闭了连接，不再发送数据；但另一侧没有关闭连接，仍可以发送数据。已关闭的一侧仍然接受数据，直到对侧也关闭了连接。




状态编码

下表为TCP状态码列表，以S指代服务端，C代表客户端，S&C表示两者，S/C表示两者之一。

LISTEN S
    服务端等待从任意远程TCP端口的连接请求。侦听请求。

SYN-SENT C
    客户在发送连接请求后等待匹配的连接请求。通过connect()函数想服务器发出一个同步（SYNC）信号后进入此状态。

SYN-RECEIVED S
    服务器已经收到并同步发送（SYNC）信号之后等待确认（ACk）请求

ESTABLISHED S&C
    服务器与客户的连接已经打开，收到的数据可以发送给客户。数据传输步骤的正常情况。此时两端是平等的。称为全链接

FIN-WAIT-1 S&C
    （服务器或客户）主动关闭daunt调用close() 函数发出FIN请求包，表示本方的数据发送全部结束，等待TCP链接另一端的ACK确认包或  FIN&ACK请求包。

FIN-WAIT-2 S&C
    主动关闭端在FIN-WAIT-1状态下收到ACK确认包，进入等待远程TCP的链接终止请求的班关闭状态。这时可以接收数据但不再发送数据。

CLOSE-WAIT S&C
    被动关闭端接到FIN后，就发出ACK已回应FIN请求，并进入等待本地用户的链接终止的办关闭状态。这时可以发送数据，但是不再接收数据。

CLOSING S&C
    在发出FIN后，又收到对方发来的FIN后，进入等待对乙方的连接终止（FIN）的确认（ACK）的状态，不过这种状态极少。

LAST-ACK S&C
    主动关闭端全部数据发送完成之后，想主动关闭端发送FIN，进入等待确认包状态。

TIME-WAIT S/C
    主动关闭端接收到FIN后，就发送ACK包，等待足够时间以确保被动关闭端收到了终止请求的确认包。（按照RFC 793，一个连接可以在TIME-WAIT 保证最大四分钟，既最大分段寿命（maximum segment lifetime）的两倍）

CLOSED S&C
    完全没有连接





- 渲染阶段

    1. 绘制dom树（DOM）
    2. 绘制style树（styleSheets）
    3. 创建布局树（Layout）
    4. 对布局树分层（有层叠样式z-index，裁剪clip）进行分层（Layer）
    5. 为每个图层生成绘制列表，并将其提交到合成线程(Paint)
    6. 合成线程将图层分成图块，并在**光栅线化程池**中将图块转化成位图
    7. 合成线程发送绘制图块的命令DrawQuad给浏览器进程
    8. 浏览器进程根据DrawQuad 消息生成页面，并显示到显示器中


- 重排从第一步重新开始
- 重绘直接跳过布局线程，重新绘制




[参考文献](https://zh.wikipedia.org/wiki/%E4%BC%A0%E8%BE%93%E6%8E%A7%E5%88%B6%E5%8D%8F%E8%AE%AE)