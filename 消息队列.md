#### 消息队列

浏览器的页面是由消息队列和事件循环系统来驱动的。渲染进程都有一个主线程，并且主线程非常繁忙，既要处理DOM，又要计算样式，还要处理布局，同时还需要处理javascript任务以及各种输入事件。要让这么多不同类型的任务在主线程中有有条不紊的执行，就需要一个系统来统筹调度这些任务，这个统筹调度系统就是我们今天要讲的消息队列和事件循环系统。

消息队列是一种数据结构，可以存放要执行的任务。它符合队列“先进先出”的特点，也就是说要添加任务的话，添加到队列的尾部；要去除任务的话，从队头部取。浏览器进程专门有个IO线程来接收其他进程传进来的消息，接收到消息后，会将这些消息组装成任务发送给渲染主线程，这些消息包括：输入事件（鼠标滚动、点击、移动）、微任务、文件读写、WebSocket、Javascript定时器等。

除此之外，消息队列中还包含了很多与页面相关的事件，如Javascript执行、解析、DOM、样式计算、布局计算、CSS动画等

#### 如何安全的退出

当页面主线程执行完成之后，又该如何保证页面主线程能够安全退出呢？Chrome是这样解决的，确定要退出当前页面时，页面主线程会设置一个退出标志的变量，在每次执行完一个任务时，判断是否有设置退出标识。如果设置了，就会直接退出所有任务，退出线程。

```c++
TaskQueue task_queue；
void ProcessTask();
bool keep_running = true;
void MainThread(){
  for(;;){
    Task task = task_queue.takeTask();
    ProcessTask(task);
    if(!keep_running) //如果设置了退出标志，那么直接退出线程循环
        break; 
  }
}
```


#### 页面使用单线程的缺点

页面线程所有执行的任务都是来自于消息队列。消息队列是“先进先出”的属性，也就是说放入队列中的任务，需要等待前面的任务被执行完，才会轮到下一个任务执行。鉴于这个特点，就需要解决两个问题。

1. 如何处理高优先级的任务

比如一个典型的场景是监控dom节点变化情况（节点的插入、修改、删除等动态变化），然后根据这些变化来处理相应的业务逻辑。一个通用的设计是，利用javascript设计一套监听接口，当变化发生时，渲染引擎同步调用这些接口，这是一个典型的观察者模式。

不过这个模式有个问题，因为dom变化非常频繁，如果每次发生变化时都直接调用响应的javascript接口，那么这个当前的任务执行时间会被拉长，从而导致执行效率的下降。

如果将这些dom变化做成异步消息时间，添加到消息队列的尾部，那么又会影响到监控的实时性，因为在添加到消息队列过程中，可能前面有很多任务在排队了。

如果dom发生变化，采用同步通知的方式，会影响当前任务的执行效率，如果采用异步方式，又会影响到监控的实时性。

针对以上情况，微任务就应用而生了。通常我们把消息队列中的任务成为**宏任务**，每个宏任务中都包含了一个**微任务队列**，在执行宏任务过程中，如果dom有变化，就会将该变化加到微任务队列中，这样就不会影响到宏任务继续执行，因此解决了执行效率的问题。

等宏任务中的主要功能都直接完成之后，渲染引擎不着急去执行下一个宏任务，而是执行当前宏任务中的微任务，因为dom变化的时间都保存在这些微任务队列中，这样就解决了实时性问题。

2. 解决单个任务执行时长过久的问题

因为所有的任务都是在单线程中执行的，所以每次只能执行一个任务，而其他任务都处于等待状态。如果一个任务执行时间太久，那么下一个任务就要等待很长时间。比如执行javascript脚本等等。如果在执行动画过程中，有个javascript任务因执行时间过久，占用了动画单帧的时间，这样会给用户制造了卡顿的感觉，这当然是极不好的用户体验。针对这种情况javascript可以用过回调功能来规避这种问题，也就是让要执行的javascript任务滞后执行。




#### 浏览器怎么实现setTimeout

要了解定时器的工作原理，我们先来回顾下时间循环系统，我们知道渲染进程所有运行在主线程上的任务都需要添加到消息队列，然后时间循环系统再按照顺序执行消息队列中的任务。下面看看典型的事件：
    - 当接收HTML文档数据，渲染引擎就会将“解析DOM”事件添加到消息队列中。
    - 用户改变了Web页面窗口大小，渲染引擎就会将“重新布局”的事件添加到消息队列中。
    - 当触发了Javascript引擎垃圾回收机制，渲染引擎会将“垃圾回收”任务添加到消息队列中。
    
    - 执行一段异步javascript代码，也是需要将执行任务添加到消息队列中。

以上列举的只是一小部分事件，这些事件被添加到消息队列之后，事件循环系统就会按照消息队列中的顺序来执行事件。

Chrome除了正常使用的消息队列之外，还有另外一个消息队列，这个队列中维护了需要延迟执行的任务列表，包括了定时器和Chromium内部一些需要延迟执行的任务。所以当通过javascript创建一个定时器，渲染进程会将该定时器的回调任务添加到延迟队列中。


加入延迟队列代码如下：

```c++

void ProcessTimerTask(){
  //从delayed_incoming_queue中取出已经到期的定时器任务
  //依次执行这些任务
}

TaskQueue task_queue；
void ProcessTask();
bool keep_running = true;
void MainTherad(){
  for(;;){
    //执行消息队列中的任务
    Task task = task_queue.takeTask();
    ProcessTask(task);
    
    //执行延迟队列中的任务
    ProcessDelayTask()

    if(!keep_running) //如果设置了退出标志，那么直接退出线程循环
        break; 
  }
}

```
从上面代码看出，我们添加了一个ProcessDelayTask函数，该函数是专门用来处理执行延迟执行任务的。这里我们要重点关注它的执行时机，处理完消息队列中的一个任务之后，就开始执行ProcessDelayTask函数。ProcessDelayTask函数会根据发起时间和延迟时间计算出到期的任务，然后一次执行这些到期的任务。等到期的任务执行完成之后，再继续下一个循环过程。通过这样的方式，一个完整的定时器就出现了。

设置一个定时器 javascript引擎会返回一个定时器id，那通常的情况下，当一个定时器的任务还没有被执行的时候，也是可以取消，具体方法调用`clearTimeout`函数，并传入需要取消的定时器id。

其实浏览器内部取消定时器实现也非常简单，就是直接从delayed_incoming_queuey延迟队列中，通过ID查找对应的任务，然后将其从队列中删除既可。


#### 使用setTimeout 注意事项

1. 如果当前任务执行时间过久，会影响定时器的执行

```javascript
function bar() {
    console.log('bar)
}


function foo() {
    setTimeout(bar,0)
    for(let i = 0; i< 5000; i++) {
        let i = 5+8+8+8;
        console.log(i)
    }
}

```


2. 如果setTimeout 存在嵌套调用，那么系统会设置最短时间建个为4毫秒


也就是说定时器函数里嵌套定时器，也会延长定制器执行时间，可以看下面这段代码：

```javascript
function cb() {setTimeout(cb, 0)};
setTimeout(cb, 0)

```


3. 未激活的页面，setTimeout 执行最小间隔是1000

除了4毫秒延迟，还有一个容易忽略的地方，就是未激活页面中定制器最小值大于1000毫秒，也就是说，如果标签不是当前激活标签，那么定时器间隔时间是1000毫秒，目的是为了优化后台页面的加载损耗以及降低耗电量。这一点使用定时器要注意。


4. 延时执行时间最大值

除了要了解定时器的回调函数时间比实际设定值延后之外，还有一点需要注意，那就是Chrome、Safari、Firefox都是以32个bit来存储延时值的，32bit最大只能存放的数字是2147483647毫秒，这就意味着，如果setTimeout设置的延时值大于这个值，就会溢出，那就相当于延时值被设置为0，这导致定时器立即执行。


```javascript
function showName(){
  console.log("极客时间")
}
var timerID = setTimeout(showName,2147483648);//会被理解调用执行
```

5. 如果被setTimeout推迟执行的回调函数是某个对象的方法，那么该方法中的`this`关键字将指向全局变量，而不是定义时所在的那个对象。看下面例子：

```javascript
var name= 1;
var MyObj = {
  name: 2,
  showName: function(){
    console.log(this.name);
  }
}
setTimeout(MyObj.showName,1000)

```

[来源](https://time.geekbang.org/column/article/135624)