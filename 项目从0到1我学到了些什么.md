#### 基础架构搭建



本篇文章阐述了咱们云客的项目从着手开发到上线大致所需要的哪些步骤。（本文仅属于我们自己搭建的情形，当我们使用公司统一架构时，以下内容都已经被做好了，我们就搬砖就好啦）

###### 一、文章背景：

因为之前经历过一个简单的hr系统的开发到上线，后来我又到项目一组做了个简单的h5支付页面，需要单独部署。这两个项目的上线的步骤都不太一样，因为前一个项目是公有云的方式，后者是私有化的方式，所以所需要做的一些准备也不相同。因为在中间踩过一些坑，所以给大家分享下我的一些心得吧！

##### 二、目的

此文章记录目的，为了记录咱们项目的整个流程，以及对过程中可以避免的坑做记录，方便以后查看。但是每个项目的不都一致，只是作为参考。

##### 三、实现过程

项目的历程我分为三个时间段来阐述

1. 项目的前期—调研，项目搭建

首先调研的话，不同的大佬有不同的方式，这里我说下个人观点吧。调研的话我觉得可以从以下几点入手：

​		a. 技术栈考虑，首先从公司层面考虑，如果公司沒有要求，或者沒有現成的框架。我觉得可以是自己熟悉的技术栈，因为这样上手快，缩小时间成本。其次可以从当前热门框架中选择，紧跟潮流的意思，也是让自己学习一个新框架。选技术框架/技术库的时候有几点考虑；（1）在github中看所选择框架的star数，很明显star越高收追捧度越高，当我们遇到框架bug时，也有更多的解决方式。（2）看项目是否持续维护，如果项目不在维护，还是那个问题，我们提issue无人问津，问题得不到解决。（3）看技术生态，技术生态越丰富的话，我们的开箱即用的UI框架越多，节省时间，毕竟用的人比较多，问题较少，比如react/vue。说了这几点也只是在我们在选择技术，框架时一些参考点，最重要的还是适合为主吧，因为我们还要根据项目的背景，需求来进行选择，也不完全是想用什么框架就用。

​		b. 使用的框架，脚手架，把包工具。（如果时间允许的情况下，我建议使用**技术栈**+**打包工具**自己手动搭建一个系统，这样一来可以学习到一些打包面的技术，也可以对框架搭建流程熟悉，对自己技术提升也有帮助）

​		c. 代码规范，代码管理。我们可以使用eslint、tslint、style-lint来约束代码风格。代码管理我们可以git，git-commit等

​		d. 我们如果使用react进行开发的话，我们一般打包构建工具使用webpack，感觉webpack现在已经是我们必不可少的打包工具了，但是我们也可以使用rollup，gulp，他们之间的差异和优劣处，这里就不细说了。如果使用vue开发的话我们依然可以是webpack，但是我们也可以尝试使用新兴的构建工具vite，这样也能试试vite香不香。

​	e. request 封装，这里分基于axios版本，和基于fetch版本

```js
// 基于fetch

// 基于axios

```



项目搭建：

做好了上述的前期准备，我们接下来就可以使用webpack或者其他工具进行项目搭建，接下来就是根据文档来操作了，loader、plugin，devServer结合。比如最简单的例子

```js
const path = require('path');


module.export = {
    entry: './index.html',
    output: {
        path: path.resolve(__dirname, 'dist'),
        filename: 'my-first-webpack.bundle.js'
    },
    mode: 'development',
    module: {
        rules: [
            { test: '/\.css$/', use: 'css-loader' },
            { test: '//\.ts$', use: 'ts-loader' }
        ]
    },
    plugins: [
            
    ]
}
```

其实在我们真正开发场景比较复杂，配置项也比较多，不仅仅是这么几行代码，所以我们在使用时要不断去熟悉学习webpack。

2. 项目中期—开发

我们通过调研，技术选型，搭建的系统。我们现在已经可以上手开发了，在开发前我们需要封装一些公共的方法，比如request，错误处理，全局异常捕获等，这么做的目的是为了更好的统一吧，因为不可能一人一套封装，这样项目显得很乱，没有章法。接下来就是配合分工问题，排期，这种就没什么可说了，千人千面，分工方式不同，就不谈了，剩下就是按照UI设计图进行开发。UI开发后就是接口对接了，这个就。。。。算了。

3. 项目上线—部署

通过联调完毕，测试结束后，接下来我们就是部署了，也是本文的重点吧，因为我们这里部署使用了cdn方式。这里主要是参考[容器化部署](https://ci-cd.myscrm.cn/doc/#/docker/web),这个文档一步步来操作，因为我们只是使用到其中一部分，所以我把它提取出来讲解。先看原始的示例

```javascript
    const YunkeSettingPlugin = require('@yunke/yunke-setting-plugin');

    module.exports = {
        plugins:[
            new YunkeSettingPlugin({
                // outputDir 代表输出目录
                // 默认是 dist
                outputDir: 'build',
                // deployType 有两个值可选，分别为：host-machine 和 docker，默认是 docker
                // 内部会根据值来处理 output.publicPath 和 output.path
                // host-machine 打包构建时为宿主机模式，本地生成文件目录为: ${项目根目录}/${outputDir}/projects/${project_name}
                // docker 容器化部署模式，本地生成文件目录为: ${项目跟目录}/${outputDir}
                deployType: 'host-machine',
                // 是否覆盖原 webpack output.publicPath，默认是覆盖
                coverPublicPath: true,
                // NODE_ENV 值的映射
                // 默认情况下，本地启动 dev 环境 NODE_ENV 为 development
                // 本地启动 test 环境，NODE_ENV 为 test
                // 如有不同，替换即可，例如 envMap: { development: { 'develop' } }
                envMap: {
                    development: 'development',
                    test: 'test'
                }
            })
        ]
        
    }
```


i. 先看私有化的配置方式
```js

// 文章中只是说需要传入不同参数，也给了个示例的路径地址，但是我感觉还是有点抽象，自己实现了一遍才清晰
const YunkerSettingPlugin = require('@yunke/yunke-setting-plugin')

const setting = new YunkerSettingPlugin({
    deployType: 'host-machine',
})
module.exports = {
      output: {
        path: process.env.NODE_ENV === 'development' ? path.resolve(__dirname, "dist") : setting.getPath(), // 这里就是我们打包后cnd的地址
        filename: 'js/index.js',
        publicPath: '/', //https://testhd-static.myscrm.cn/dist/projects/pay_h5/
    },
}

```
 ii. 公有云的配置方式，注意看参数不同，

    ```js
    // （1）这个是Umi框架的配置方式，配置插件写法不同，但是性质一样的。
    const YunkerSettingPlugin = require('@yunke/yunke-setting-plugin')
    module.exports = {
        // 在Umi框架的配置中虽然写法不一样，但是意思相同
     chainWebpack: (memo) => {
        memo.plugin('setting').use(YunkerSettingPlugin, [{ deployType: 'docker' }]); },
    }
    // （2）Taro H5中配置也是一样的，参数相同，只是写法不同module.exports = {
          // cdn走静态资源
        webpackChain(chain, webpack) {
          chain.merge({
            plugin: {
              install: {
                plugin: require('@yunke/yunke-setting-plugin'),
                args: [{
                  deployType: 'docker'
                }]
              }
            }
          })
        }
    }
        ```

**注**：通过两个不同的例子，就很好的理解了，我们私有化和公有云的部署配置方式不同之处。其次我们在项目即将部署的时候在项目中做的也不一样，因为当我们公有云的项目在gitLab上被创建时，就会有一个.gitlab-ci.yml的文件，这是一个脚本针对容器化部署，云客部署构建文章中也可以找到，这里不赘述了。再一个我们项目中还需要添加两个文件，Nginx配置和docker部署的两个文件。私有化部署的话很简单---找运维。

**Nginx文件**

```js
server {
  listen 9000;
  ssi    on;

  access_log  /var/log/service/access/access.log  main;
  error_log  /var/log/service/err/error.log  error;

  root /app/dist;
  index  index.html index.htm index.shtml;

  location / {
    expires -1;
    try_files $uri /index.html;
  }
}
```

iii. 走cdn的时候我们根据传入不同的参数，得到结果也不一样，里面的逻辑究竟是如果，我们接下来看看这个插件做了哪些事情,插件源码一百多行，很简单，我就不全部列出来，我就列一下根据不同的参数返回不同的路径的代码

```js
const DEPLOY_TYPE = {
  MACHINE: 'host-machine',
  DOCKER: 'docker'
}

// 获取项目名称
  getProjectName() { 
    return require(`${process.cwd()}/package.json`).name;
  }

// 获取项目路径
  getPath() {
    const project_name = this.getProjectName()
    const { deployType, outputDir } = this.options
    if (deployType === DEPLOY_TYPE.MACHINE) {
      return path.resolve(process.cwd(), `./${outputDir}/projects/${project_name}`)
    }
    return path.join(process.cwd(), outputDir)
  }

// 获取cdn的路径
  getPublicPath() {
    const project_name = this.getProjectName()
    const { deployType, outputDir } = this.options
    if (deployType === DEPLOY_TYPE.MACHINE) {
      return `${getHost('cdn', defaultCdnHost)}/${outputDir}/projects/${project_name}/`.replace('http://', 'https://')
    }
    return `__PUBLIC_PATH__/dist/${project_name}-__YUNKE_VERSION__/`.replace('http://', 'https://')
  }


```

**注：**

当我们使用yunke的ycli脚手架搭建时我们在配置文件可以按照这个云客ycli](https://git.myscrm.cn/yued/ycli)操作，配置私有化时只需要在config文件中添加属性J即可。

```js
yunkerSettingPluginOption: {
    deployType: 'host-machine'
}
```





4. 欠缺点：BFF部署方式还未实战
5. 总结

当我们完成一个整个项目搭建的时候，我们可以获得以下收获：

（1）. 对项目总体概率有了质的提升

（2）. 项目整体结构很清晰，功能点清楚

（3）. 排查问题能力，速度提升

....

以上内容仅供参考，当我们开发中遇到，还视情况而定，当我们部署遇到问题，还得看[容器化部署](https://ci-cd.myscrm.cn/doc/#/docker/web)这篇文章，因为他们的代码更新快，如有不知道的还是需要询问工具组的同事.

项目搭建好以后，接下来就是写业务代码了，我们再写业务代码时，我也有一些感悟

#### 对业务代码的思考

一. 思考如何用一些优雅的方式去实现我们的代码编写，比如学习一些设计模式，函数式编程等思想在我们开发中尝试使用。  

设计模式初衷是把变化和不变的东西分别开来，抽离出来封装成为函数，可以互相替换，和使用。

先来来看看如何利用设计模式如何写好优雅代码

（1）策略模式

